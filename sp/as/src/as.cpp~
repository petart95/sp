#include "as.h"

#include "OperationFunctions.h"
#include "DirectiveFunctions.h"

#include "Operation.hpp"
#include "ProcessString.h"

#include <algorithm>

std::ifstream in;
std::ofstream out;

std::vector<Simbol> simbolTabel;
std::vector<Section> sectionTabel;
int currentSectionIndex = 0;

void openFiles(std::string inFile) {
	in.open(inFile.c_str(), std::ifstream::in);

	std::string outFile = inFile + ".o";
	if(inFile.find(".") != std::string::npos) {
		outFile = inFile.substr(0, inFile.find(".")) + ".o";
	}

	out.open(outFile.c_str(), std::ifstream::out);
}

void closeFiles() {
	in.close();
	out.close();
}

void init(int argc, char** argv) {
	initLog();

	if(argc != 2) {
		printf("Usage: as [file]\n");
		exit(0);
	}

	openFiles(std::string(argv[1]));

	setOperationFunctionsForFirstPass();
	setDirectivFunctionsForFirstPass();
}

void initForSeconPass() {
	in.clear();
	in.seekg (0, std::ios::beg);

	setOperationFunctionsForSecondPass();
	setDirectivFunctionsForSecondPass();

	isExitFlagSet = false;

	currentSectionIndex = 0;

	for(int i = 0; i < sectionTabel.size(); i++) {
		sectionTabel[i].locationCounter = 0;
	}
}

void close() {
	closeLog();

	closeFiles();
}

std::string removeCommentsFromLine(std::string line) {
	// Check for @ coments
	if(line.find("@") != std::string::npos) {
		line = line.substr(0, line.find("@"));
	}

	// Check for // coments
	if(line.find("//") != std::string::npos) {
		line = line.substr(0, line.find("//"));
	}

	return line;
}

void processLineFirstPass(std::string line) {
	// Check for label
	if(line.find(":") != std::string::npos) {
		std::string label = line.substr(0, line.find(":"));

		line = line.substr(line.find(":") + 1);

		Simbol(label, sectionTabel[currentSectionIndex].locationCounter, currentSectionIndex);
	}

	// Split string
	std::vector<std::string> split = splitStringWhitCharacterSet(line, " ,");

	if(split.size() == 0) {
		return;
	}

	// Cretae simbol tabel
	if(split[0].find(".") != std::string::npos) {
		int numberOfDots = std::count(split[0].begin(), split[0].end(), '.');
		std::string directiv(split[0]);
		if(numberOfDots > 1) {
			directiv = directiv.substr(0, directiv.find_last_of('.'));
		}
		if(isDirectivSupported(directiv)) {
			(*handelDirectiv[directiv])(split);
		} else {
			log("***ERORR*** Directiv: " + split[0] + " not supported");
		}
	} else {
  
		sectionTabel[currentSectionIndex].locationCounter += 4;
	}
}

void processLineSecondPass(std::string line) {
	// Check for label
	if(line.find(":") != std::string::npos) {
		line = line.substr(line.find(":") + 1);
	}

	// Split string
	std::vector<std::string> split = splitStringWhitCharacterSet(line, " ,");

	if(split.size() == 0) {
		return;
	}

	// Cretae simbol tabel
	if(split[0].find(".") != std::string::npos) {
		int numberOfDots = std::count(split[0].begin(), split[0].end(), '.');
		std::string directiv(split[0]);
		if(numberOfDots > 1) {
			directiv = directiv.substr(0, directiv.find_last_of('.'));
		}
		if(isDirectivSupported(directiv)) {
			(*handelDirectiv[directiv])(split);
		} 
	} else {
		Operation operation(split);
		if(operation.isOperationValid()) {
			sectionTabel[currentSectionIndex].data += operation.createHexRepresentation();
        	} else {
            		if(!operation.opcode.isValid) {
                		log("***ERROR*** Opcode for operation:" + line + ", is invalid");
       		     	} else {
                		log("***ERROR*** Operands for operationl: " + line + ", are invalid");
            		}
        	}
		sectionTabel[currentSectionIndex].locationCounter += 4;
	}
}

int main(int argc, char** argv) {
	init(argc, argv);
	
	std::string line;
	
	// First pass	
	while (getline(in, line) && !isExitFlagSet) {
		processLineFirstPass(removeCommentsFromLine(line));
	}

	initForSeconPass();

	// Second pass
	while (getline(in, line) && !isExitFlagSet) {
		processLineSecondPass(removeCommentsFromLine(line));
	}

	out << "# Tabela simbola\n";
	out << "# ";
	out << std::left << std::setw(4) << std::setfill(' ') << "ID";
	out << std::left << std::setw(15) << std::setfill(' ') << "Name";
	out << std::left << std::setw(9) << std::setfill(' ') << "Offset";
	out << std::left << std::setw(11) << std::setfill(' ') << "Section ID";
	out << std::left << std::setw(13) << std::setfill(' ') << "Global/Local";
	out << std::left << std::setw(18) << std::setfill(' ') << "Defined/Undefnded";
	out << "\n";
	for(int i = 0; i < simbolTabel.size(); i++) {
		out << "  ";
		out << std::left << std::setw(4) << std::setfill(' ') << simbolTabel[i].id;
		out << std::left << std::setw(15) << std::setfill(' ') << simbolTabel[i].name;
		out << std::left << std::setw(9) << std::setfill(' ') << toHexadecimal(simbolTabel[i].offset, 8);
		out << std::left << std::setw(11) << std::setfill(' ') << simbolTabel[i].sectionIndex;
		out << std::left << std::setw(13) << std::setfill(' ') << (simbolTabel[i].isGlobal ? "Global" : "Local");
		out << std::left << std::setw(18) << std::setfill(' ') << (simbolTabel[i].isDefined ? "Defined" : "Undefnded");
		out << "\n";
	}


	for(int i = 0; i < sectionTabel.size(); i++) {
		out << "\n";
		out << "# " << sectionTabel[i].name << "\n";
		out << sectionTabel[i].data << "\n";
		out << "\n";

		out << "# .ret" << sectionTabel[i].name << "\n";
		out << "# ";
		out << std::left << std::setw(9) << std::setfill(' ') << "Offset";
		out << std::left << std::setw(20) << std::setfill(' ') << "Type";
		out << std::left << std::setw(4) << std::setfill(' ') << "Simbol ID";
		out << "\n";
		out << sectionTabel[i].realocation;
	}	

	close();

	return 0;
}
